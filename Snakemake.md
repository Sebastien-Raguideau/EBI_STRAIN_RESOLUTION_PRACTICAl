## Snakemake

The Snakemake workflow management system is a tool to create **reproducible and scalable** data analyses. Workflows are described via a human readable, Python based language. They can be seamlessly scaled to server, cluster, grid and cloud environments, without the need to modify the workflow definition. Finally, Snakemake workflows can entail a description of required software, which will be automatically deployed to any execution environment.

Alternatives: 
 - [nextflow](https://www.nextflow.io/)
 - Common workflow language and it's implementations : [CWL](https://www.commonwl.org/#Implementations)

### Principle

The user define :

-   a set of rules, which are scripts/command line, encapsuled in a way snakemake can make sense of.
-   an expected results : a file or a list of files
-   an amount of ressources : number of cpu, memory

Snakemake then devise the succession of rules (script/command) needed to generate the output. If the results cannot be generated from the rules inputed and the files already present in the execution folder, snakemake will let you know and fail.

Snakemake will schedule rules excution optimising ressources allocations (threads/memory/custom ressource).

### Features

-   It is possible to write and use python code inside snakemake
-   snakemake keep track of all files, input input in your workflow. If the input of a rule has been updated, snakemake will rerun all depending rules.
-   snakemake keep track of completion of tasks and can deal with unplanned interuption.
-   snakemake can be easily deployed to clusters without changing any code
-   It is possible to specify ad hoc environment for each step of the pipeline and have each step executed in it's own environment

#### Snakemake rule

The minimum rule is :

-   an input
-   an output
-   a shell command/or python code

Example :

```
 rule prodigal:
    input: "contigs.fa"
    output: faa="contigs.faa",
            fna="contigs.fna",
            gff="contigs.gff"
    shell:
        "prodigal -i {input} -a {output.faa} -d {output.fna} -f gff -o {output.gff} -p meta "

```
By specifying a results, for instance contig.gff, snakemake will look at all available rules and look for any able to output contig.gff. In this case only prodigal is present and snakemake will look for contigs.fa.

Let's try to call genes on the low resolution assembly:

    cd Strain_resolution
    mkdir snakemake
    cd snakemake
    nano prodigal.snake
Paste the previous rule and replace input by `STRONG_run/assembly/spades/assembly.fasta` 
Replace output with `STRONG_run/annotation/assembly.faa/fna/gff`

    cd ~/Strain_resolution
    snakemake -s snakemake/prodigal.snake STRONG_run/annotation/assembly.faa -n -r
Then 

    snakemake -s snakemake/prodigal.snake STRONG_run/annotation/assembly.faa

Nothing is happening. Why?
Try again with 

    snakemake -s snakemake/prodigal.snake STRONG_run/annotation/assembly.faa -R prodigal

**Additional rule entry**

-   threads : number of threads the rule needs, default = 1
-   log file
-   params : additional parameters
-   singularity/conda : specify rule specific environment
-   report : report automatically generated by snakemake
-   message : message printed during execution
-   priority : allow to encourage execution of certain task before others

**Wildcards** Wildcards are keywords between {} used to make rule more general and applicable to multiple situations.

```
rule prodigal:
    input: "{genome}.fasta"
    output: faa="{genome}.faa",
            fna="{genome}.fna",
            gff="{genome}.gff"
    params: mode=PRODIGAL_MODE
    log:    "{genome}.log"
    shell:
        "prodigal -i {input} -a {output.faa} -d {output.fna} -f gff -o {output.gff} -p {params.mode} &>> {log}"

```


{genome} can be replaced by a file name, or a path.

    cd  STRONG_run/annotation/
    ln -s ../assembly/spades/assembly.fasta .
    cd 
    cd Strain_resolution/snakemake
    nano prodigal_MK2.snake
Paste the previous rule and without any change,

    cd  
    cd Strain_resolution
    snakemake -s snakemake/prodigal.snake STRONG_run/annotation/assembly.faa -n -r

Why does it work? Why the symbolic link?


### To go further

-   Snakemake works in reverse, it start from the specified output and looks for rules/recipes able to generate it. It try also multiple wildcards values until it find a way to generate the output.
-   As a snakemake grow bigger, ambiguity in rules may pop up : 2 rules with the same output. And thus, 2 rules/recipe to create the same input. To solve this issue, you need to restrict your rules making them less universal, either a specific path (prodigal/{genome.gff}), or a specific filename [genome}_prodigal.gff. You can also constrain wildcards or specify a priority of rules.
-   Snakemake will resolve the sequence of rules execution before starting --> if you don't know beforehand the number of files generated, it makes things more complicated. The solution is to use flags, to execute multiple independant snakemake or to use checkpoints

